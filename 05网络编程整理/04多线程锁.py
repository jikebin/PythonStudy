'''
多线程锁整理：
大纲：简单线程锁、递归锁、信号量(并行锁)、条件变量锁(等待唤醒机制)、死锁现象、GIL与线程锁的区别
------------------------------------------------------------------------------------------------------------------
简单锁：
大纲：实现、说明
实现：
import threading
    lock = threading.Lock()
    lock.acquire()  #获取锁
    执行代码
    lock.release() #释放锁
说明：
    简单锁，一个锁对象，一次只能调用一次acquire()，等锁释放后，才可以再次调用 #所以会造成死锁现象
------------------------------------------------------------------------------------------------------------------
递归锁：(复用锁)
大纲：实现、说明
实现：
import threading
    lock = threading.Rlock()
    lock.acquire()  #获取锁
    lock.acquire()  #获取锁
    执行代码
    lock.release() #释放锁
    lock.release() #释放锁
说明：
    递归锁，一个锁对象可以调用多次acquire(),实现锁的嵌套，内部拥有一个计数器，每增加一个就会+1.不会造成死锁现象
------------------------------------------------------------------------------------------------------------------
信号量：（并行锁）
大纲：实现、说明
实现：
import threading
    lock = threading.BoundedSemaphore(5) #同时可以有5个线程进入锁内
    lock.acquire()  #获取锁
    执行代码
    lock.release() #释放锁
说明：
    信号量(并行锁)，只能加一次锁，该锁允许多个线程同时进入锁内
------------------------------------------------------------------------------------------------------------------
条件变量：锁(进行线程之间的交互，生产者消费者模式，等待唤醒机制)
大纲：实现、补充方法、说明
import threading
    lock = threading.Condition()默认参数为RLock
    lock.acquire()  #获取锁
    执行代码
    lock.release() #释放锁
补充方法：
    wait()          等待(释放锁，并等待)
    notify()        唤醒(激活一个线程)
    notifyAll()		唤醒(激活所有线程)
说明：
    条件变量锁，额外拥有三个方法
------------------------------------------------------------------------------------------------------------------
死锁现象：
大纲：死锁的基本条件、死锁现象、解决方案
死锁基本条件：
    1.两把简单锁
    2.两个函数
    3.每个函数都嵌套两把锁
    4.每个线程都同时调用这两个函数
死锁现象：
    A锁等B锁，B锁等A锁。A锁套B锁，B锁套A锁。 造成死锁
解决方案：
    使用递归锁：Rlock(),来替换锁A和锁B
------------------------------------------------------------------------------------------------------------------
GIL与线程锁的区别：
    GIL:同一时间只能有一个线程进入解释器
    线程锁：保证加锁部分运算时cpu不进行切换
补充说明：
    1.为什么多线程要加锁？
        多线程之间会进行数据共享，而要保证数据操作过程中的完整性，则必须加锁
    2.为什么要保证cpu不进行切换？
        python中由于有GIL,所以多线程仅仅只是并发操作，而非并行操作。这时，保证加锁部分运算时不切换CPU资源就能保证数据的完整性
'''