'''
网络编程复习：
大纲：网络通信、多线程网络通信、多线程1、多线程锁、队列、进程通信与数据共享、协程
--------------------------------------------------------------------------------------------------------------------
网络通信：socket
大纲：网络通信三要素、socket的使用、粘包、文件上传
网通三要素：
    IP/端口/协议
网络通信：
    服务器：socket()--->address--->bind()--->listen()--->accept     等待连接
    客户端：socket()--->address--->connect()
    一收一发：recv(1024) <--- send()/sendall()bytes
    关闭：close()
粘包：
    中间加入一个接收
文件上传：
    1.建立连接
    2.获取信息
    3.一读一写
--------------------------------------------------------------------------------------------------------------------
多线程网络通信：socketserver
大纲：实现、说明
说明：
    socketserver是对socket的封装，简化开发
实现：
import socketserver
    1.创建类：继承 socketserver.BaseRequestHandler
    2.重写：handle()方法
    3.创建对象：socketserver.ThreadingTCPServer(address,类名)
    4.调用：server_forever() 启动服务器

--------------------------------------------------------------------------------------------------------------------
多线程：threading
大纲：两种实现、补充方法、定义说明
import threading
    面向过程：
        t1 = threading.Thread(target=function,args=(参数,...))
        t1.star()
    面向对象：
        1.创建类：继承threading.Thread
        2.子类构造调用父类构造
        3.重写run()方法
        4.创建对象
        5.调用start()
补充方法：
    join()      #阻塞
    setDas...() #守护
定义说明：
    线程与进程：
    并发与并行：
    IO密集和计算密集：

--------------------------------------------------------------------------------------------------------------------
多线程锁：
大纲：四种锁、死锁、GIL与线程锁的区别
四种锁：
    普通锁、递归锁、信号量(并行锁)、条件变量(等待唤醒机制)
死锁：
    1.两把普通锁
    2.两个函数
    3.每个函数，互相嵌套两把锁
    4.每个线程同时调用这两个函数
GIL与线程锁的区别：
    GIL保证同一时刻只能有一个线程进入解释器
    线程锁：保证不切换cpu资源
--------------------------------------------------------------------------------------------------------------------
多线程队列：
import queue
q = queue.Queue()
q.put()
q.get
说明：队列是多线程利器，内部维护了一把锁
    先进先出、后进先出、优先队列
--------------------------------------------------------------------------------------------------------------------
进程通信和数据共享：
大纲：进程创建(multiprocessing.Process)、进程通信(队列(Queue)和管道(Pipe))、数据共享（Manager）
进程创建：
form multiprocessing import Process
    面向过程：
        p1 = Process(target=function,args=(参数1,...))
        p1.start()
    面向对象：
        与多线程相同
        注意：创建对象，必须在  if __name__ == '__main__': 下完成，否则报错
进程通信：
from multiprocessing import Queue,Pipe
    队列：
        1.创建队列
        2.将队列对象，传递给子进程
        3.通过 put()和get()进行通信
        原理：队列内部是通过：pickle来实现的
    管道：
        1.创建管道，返回父管道 和 子管道 两个参数
        2.将子管道传递给子进程
        3.通过 recv() 和 send(str) 进行通信
        原理：通过网络通信，来进行进程通信
数据共享：
from multiprocessing import Manager
    1.with Manager() as manager:
        l = manager.list()
        d = manager.dict()
    2.将l 和 d 传递给子进程
    3.所有进程共享数据

--------------------------------------------------------------------------------------------------------------------
协程：
大纲：实现方式、
通过yield 和  gevent第三方模块实现
    优先：
        1.高并发+高扩展+成本低
'''

